<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./styles/header.css">
    <link rel="stylesheet" href="./styles/main.css">
    <title>Tech Notes: Two surprises in browser crashes</title>
</head>
<body>
    <header class="header-area">
        <div class="left-offset">
            <h1>
                <a href="" class="header-main-navigation">neugierig.org: </a>
                <a href="" class="header-main-navigation">Tech News</a>
            </h1>
            <div>
                <span class="header-description-text">
                    You're reading a single entry. Go 
                    <a href="">back to the front page</a>
                    for more.
                </span>
            </div>
        </div>
    </header>

    <main class="left-offset">
        <h2>Two surprises in browser crashes</h2>
        <span>January 04, 2023</span>

        <p>
            You might be surprised, as I was, to learn that Chrome exposes an API to notify you when<br>
            the browser crashes on your page. It is part of a larger <a href="">reporting API</a> that is designed to give <br>
            browsers a channel to inform you, the developer, of crashes and other things.
        </p>
        <p>
            In particular for a page crash you no longer have a page or JS context to receive the event,<br>
            so the API instead POSTs some JSON to a URL you provide. Per usual there were <a href="">two slightly<br>incompatible versions of the API</a>, I imagine as they attemped to standardize. (I do not know<br>
            a lot about this space but it appears all of this is Chrome-only for now...)
        </p>
        <p>
            Figma, which is a large compley web app that often breaks browsers, uses these to monitor<br>
            for crashes. That is how I learned these systems existed - I was on call and an alert fired<br>
            about the crash rate.
        </p>
        <p>
            And here is where the second surprise appeared: the alert fired because the crash rate was<br>
            high, but a separate dashboard monitoring the crash rate appeared low. The discrepancy<br>
            turned out to be caused by a misconfiguration. We were segmenting the incoming crashes<br>
            by which portion of the site they affected, and the two systems slightly disagreed on what<br>
            they were watching.
        </p>
        <p>
            The crash rate in the core app, the browser-busting magic WASM WebGL piece that I was<br>
            attempting to monitor, had stayed level. The crash rate on a relatively static HTML<br>
            marketing page has risen! The marketing page, as I recall, has some of those swoopy CSS<br>
            animations on scroll that is common on today's marketing pages, and (edit: I has this wrong<br>
            in the first post, thanks Andrew!) and accidental change in ad targeting was bringing in a<br>
            bunch of users with lower-end mobile browsers that would crash.
        </p>
        <p>
            From this I took away an important lesson: even when your app is not pushing the<br>
            boundaries of browsers, monitoring for crashes is probably worth it. <a href="">Read this overview</a> to<br>
            get started; I believe it's as simple as providing <code>default</code> endpoint in an HTTP header and<br>
            accepting POSTs there.
        </p>
    </main>
</body>
</html>